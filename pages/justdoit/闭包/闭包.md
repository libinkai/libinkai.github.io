# 闭包

- 闭包是由函数及其相关的引用环境组合而成的实体（即闭包=函数+引用环境）

# 闭包出现的条件

- 被嵌套的函数引用到非本函数的外部变量，而且这个外部变量不是“全局变量”
- 嵌套的函数被独立了出来(被父函数返回或被赋值变成了独立的个体)， 而被引用的变量所在的父函数已结束

# Java的内部类

- 成员内部类：在类的内部再定义一个类。
  - 因为内部类依赖与外围类的存在，所以无法在**外部**直接将其实例化，而是必须先实例化外围类，才能够实例化内部类（在外围类的成员方法里仍然可以直接实例化内部类）
- 局部内部类：嵌套在方法里或者是某个作用域内，通常情况下不希望这个类是公共可用的，一般用于在内部实现一些私有的辅助功能。
- 静态内部类：使用了static关键字修饰的内部类即为静态内部类，和成员内部类最大的不同是，静态内部类没有了指向外围类的引用。 因此它的创建不需要依赖于外围类，但也不能够使用任何外围类的非static成员变量和方法。
- 匿名内部类：没有被命名的内部类。
  - 匿名内部类没有访问修饰符，也没有构造方法
  - 匿名内部类依附于接口而存在，如果它要继承的接口并不存在，那这个类就无法被创建
  - 如果匿名内部类要访问局部变量，那这个数据必须是final的

# 匿名内部类与lambda表达式

- 匿名内部类是传递的对象，而lambda表达式是传递的函数
- 匿名内部类的实现是通过创建一个类文件来实现的，lambda表达式在Java8中首先会生成一个私有的静态方法`lambda$0`，这个私有的静态方法处理逻辑就是lambda表达式里面的逻辑，`lambda$0`方法在一个实现了函数式接口的内部类的方法体中被调用。

# 闭包的变量

- 闭包中引用的外部变量必须是在堆上分配的。
- 由于Java在实现匿名内部类对外部局部变量访问时，并不是像Go的编译器那样将局部变量提升到堆中，然后传递引用来实现；而是对局部变量创建值拷贝，然后供匿名内部类来使用，所以在匿名内部类中要访问局部变量，那这个变量必须是final的。

# 参考文章

- https://juejin.im/post/6844903655510917128
- http://marklux.cn/blog/44